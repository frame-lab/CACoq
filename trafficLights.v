(* File generated by ReoXplore graphical interface *) 
(* It requires the compilation of CaMain.v file in https://github.com/frame-lab/CACoq. *) 
Require Import CaMain. 
Inductive modelPortsType := 
	a | d | e | f | g | h | b | x | i | j | k | l | m | n |  c. 
Instance modelPortsEqDec : EqDec modelPortsType eq :=
	{equiv_dec x y := 
		 match x, y with 
		| a , a => in_left 
		| a , d => in_right
		| a , e => in_right
		| a , f => in_right
		| a , g => in_right
		| a , h => in_right
		| a , b => in_right
		| a , x => in_right
		| a , i => in_right
		| a , j => in_right
		| a , k => in_right
		| a , l => in_right
		| a , m => in_right
		| a , n => in_right
		| a , c => in_right
		| d , a => in_right
		| d , d => in_left 
		| d , e => in_right
		| d , f => in_right
		| d , g => in_right
		| d , h => in_right
		| d , b => in_right
		| d , x => in_right
		| d , i => in_right
		| d , j => in_right
		| d , k => in_right
		| d , l => in_right
		| d , m => in_right
		| d , n => in_right
		| d , c => in_right
		| e , a => in_right
		| e , d => in_right
		| e , e => in_left 
		| e , f => in_right
		| e , g => in_right
		| e , h => in_right
		| e , b => in_right
		| e , x => in_right
		| e , i => in_right
		| e , j => in_right
		| e , k => in_right
		| e , l => in_right
		| e , m => in_right
		| e , n => in_right
		| e , c => in_right
		| f , a => in_right
		| f , d => in_right
		| f , e => in_right
		| f , f => in_left 
		| f , g => in_right
		| f , h => in_right
		| f , b => in_right
		| f , x => in_right
		| f , i => in_right
		| f , j => in_right
		| f , k => in_right
		| f , l => in_right
		| f , m => in_right
		| f , n => in_right
		| f , c => in_right
		| g , a => in_right
		| g , d => in_right
		| g , e => in_right
		| g , f => in_right
		| g , g => in_left 
		| g , h => in_right
		| g , b => in_right
		| g , x => in_right
		| g , i => in_right
		| g , j => in_right
		| g , k => in_right
		| g , l => in_right
		| g , m => in_right
		| g , n => in_right
		| g , c => in_right
		| h , a => in_right
		| h , d => in_right
		| h , e => in_right
		| h , f => in_right
		| h , g => in_right
		| h , h => in_left 
		| h , b => in_right
		| h , x => in_right
		| h , i => in_right
		| h , j => in_right
		| h , k => in_right
		| h , l => in_right
		| h , m => in_right
		| h , n => in_right
		| h , c => in_right
		| b , a => in_right
		| b , d => in_right
		| b , e => in_right
		| b , f => in_right
		| b , g => in_right
		| b , h => in_right
		| b , b => in_left 
		| b , x => in_right
		| b , i => in_right
		| b , j => in_right
		| b , k => in_right
		| b , l => in_right
		| b , m => in_right
		| b , n => in_right
		| b , c => in_right
		| x , a => in_right
		| x , d => in_right
		| x , e => in_right
		| x , f => in_right
		| x , g => in_right
		| x , h => in_right
		| x , b => in_right
		| x , x => in_left 
		| x , i => in_right
		| x , j => in_right
		| x , k => in_right
		| x , l => in_right
		| x , m => in_right
		| x , n => in_right
		| x , c => in_right
		| i , a => in_right
		| i , d => in_right
		| i , e => in_right
		| i , f => in_right
		| i , g => in_right
		| i , h => in_right
		| i , b => in_right
		| i , x => in_right
		| i , i => in_left 
		| i , j => in_right
		| i , k => in_right
		| i , l => in_right
		| i , m => in_right
		| i , n => in_right
		| i , c => in_right
		| j , a => in_right
		| j , d => in_right
		| j , e => in_right
		| j , f => in_right
		| j , g => in_right
		| j , h => in_right
		| j , b => in_right
		| j , x => in_right
		| j , i => in_right
		| j , j => in_left 
		| j , k => in_right
		| j , l => in_right
		| j , m => in_right
		| j , n => in_right
		| j , c => in_right
		| k , a => in_right
		| k , d => in_right
		| k , e => in_right
		| k , f => in_right
		| k , g => in_right
		| k , h => in_right
		| k , b => in_right
		| k , x => in_right
		| k , i => in_right
		| k , j => in_right
		| k , k => in_left 
		| k , l => in_right
		| k , m => in_right
		| k , n => in_right
		| k , c => in_right
		| l , a => in_right
		| l , d => in_right
		| l , e => in_right
		| l , f => in_right
		| l , g => in_right
		| l , h => in_right
		| l , b => in_right
		| l , x => in_right
		| l , i => in_right
		| l , j => in_right
		| l , k => in_right
		| l , l => in_left 
		| l , m => in_right
		| l , n => in_right
		| l , c => in_right
		| m , a => in_right
		| m , d => in_right
		| m , e => in_right
		| m , f => in_right
		| m , g => in_right
		| m , h => in_right
		| m , b => in_right
		| m , x => in_right
		| m , i => in_right
		| m , j => in_right
		| m , k => in_right
		| m , l => in_right
		| m , m => in_left 
		| m , n => in_right
		| m , c => in_right
		| n , a => in_right
		| n , d => in_right
		| n , e => in_right
		| n , f => in_right
		| n , g => in_right
		| n , h => in_right
		| n , b => in_right
		| n , x => in_right
		| n , i => in_right
		| n , j => in_right
		| n , k => in_right
		| n , l => in_right
		| n , m => in_right
		| n , n => in_left 
		| n , c => in_right
		| c , a => in_right
		| c , d => in_right
		| c , e => in_right
		| c , f => in_right
		| c , g => in_right
		| c , h => in_right
		| c , b => in_right
		| c , x => in_right
		| c , i => in_right
		| c , j => in_right
		| c , k => in_right
		| c , l => in_right
		| c , m => in_right
		| c , n => in_right
		| c , c => in_left 
	end
	}.
Proof.
all: congruence.
Defined.
Inductive replicator1StatesType := 
	q0.
Instance replicator1EqDec : EqDec replicator1StatesType eq :=
	{equiv_dec x y := 
		 match x, y with 
		| q0 , q0 => in_left 
	end
	}.
Proof.
all: congruence.
Defined.
Inductive filter2StatesType := 
	q1.
Instance filter2EqDec : EqDec filter2StatesType eq :=
	{equiv_dec x y := 
		 match x, y with 
		| q1 , q1 => in_left 
	end
	}.
Proof.
all: congruence.
Defined.
Inductive filter3StatesType := 
	q2.
Instance filter3EqDec : EqDec filter3StatesType eq :=
	{equiv_dec x y := 
		 match x, y with 
		| q2 , q2 => in_left 
	end
	}.
Proof.
all: congruence.
Defined.
Inductive sync4StatesType := 
	q3.
Instance sync4EqDec : EqDec sync4StatesType eq :=
	{equiv_dec x y := 
		 match x, y with 
		| q3 , q3 => in_left 
	end
	}.
Proof.
all: congruence.
Defined.
Inductive sync5StatesType := 
	q4.
Instance sync5EqDec : EqDec sync5StatesType eq :=
	{equiv_dec x y := 
		 match x, y with 
		| q4 , q4 => in_left 
	end
	}.
Proof.
all: congruence.
Defined.
Inductive merger6StatesType := 
	q5.
Instance merger6EqDec : EqDec merger6StatesType eq :=
	{equiv_dec x y := 
		 match x, y with 
		| q5 , q5 => in_left 
	end
	}.
Proof.
all: congruence.
Defined.
Inductive replicator7StatesType := 
	q6.
Instance replicator7EqDec : EqDec replicator7StatesType eq :=
	{equiv_dec x y := 
		 match x, y with 
		| q6 , q6 => in_left 
	end
	}.
Proof.
all: congruence.
Defined.
Inductive sync8StatesType := 
	q7.
Instance sync8EqDec : EqDec sync8StatesType eq :=
	{equiv_dec x y := 
		 match x, y with 
		| q7 , q7 => in_left 
	end
	}.
Proof.
all: congruence.
Defined.
Inductive transformer9StatesType := 
	q8.
Instance transformer9EqDec : EqDec transformer9StatesType eq :=
	{equiv_dec x y := 
		 match x, y with 
		| q8 , q8 => in_left 
	end
	}.
Proof.
all: congruence.
Defined.
Inductive sync10StatesType := 
	q9.
Instance sync10EqDec : EqDec sync10StatesType eq :=
	{equiv_dec x y := 
		 match x, y with 
		| q9 , q9 => in_left 
	end
	}.
Proof.
all: congruence.
Defined.
Inductive fifo11StatesType := 
	 q10 | 	 p0 | 	p1.
Instance fifo11EqDec : EqDec fifo11StatesType eq :=
	{equiv_dec x y := 
		 match x, y with 
		| q10 , q10 => in_left 
		| q10 , p0 => in_right 
		| q10 , p1 => in_right 
		| p0 , q10 => in_right 
		| p0 , p0 => in_left 
		| p0 , p1 => in_right 
		| p1 , q10 => in_right 
		| p1 , p0 => in_right 
		| p1 , p1 => in_left 
	end
	}.
Proof.
all: congruence.
Defined.
Inductive merger12StatesType := 
	q11.
Instance merger12EqDec : EqDec merger12StatesType eq :=
	{equiv_dec x y := 
		 match x, y with 
		| q11 , q11 => in_left 
	end
	}.
Proof.
all: congruence.
Defined.
Definition replicator1rel (s: replicator1StatesType) :=
	match s with
		 | q0 => [([a;d;e], ConstraintAutomata.andDc (ConstraintAutomata.eqDc nat a d) (ConstraintAutomata.eqDc nat a e) , q0)] 
	end.
Definition replicator1Automaton := {| 
	ConstraintAutomata.Q := [q0];
	ConstraintAutomata.N := [a;d;e];
	ConstraintAutomata.T := replicator1rel;
	ConstraintAutomata.Q0 := [q0]
|}.
Definition filter2rel (s: filter2StatesType) :=
	match s with
		 | q1 => [([d], ConstraintAutomata.negDc (ConstraintAutomata.dc d 1) , q1);
              ([d;f], ConstraintAutomata.andDc (ConstraintAutomata.dc d 1) (ConstraintAutomata.eqDc nat d f) , q1)] 
	end.
Definition filter2Automaton := {| 
	ConstraintAutomata.Q := [q1];
	ConstraintAutomata.N := [d;f];
	ConstraintAutomata.T := filter2rel;
	ConstraintAutomata.Q0 := [q1]
|}.
Definition filter3rel (s: filter3StatesType) :=
	match s with
		 | q2 => [([e], (ConstraintAutomata.dc d 1) , q2);
              ([e;g], ConstraintAutomata.andDc (ConstraintAutomata.negDc (ConstraintAutomata.dc d 1)) (ConstraintAutomata.eqDc nat e g) , q2)] 
	end.
Definition filter3Automaton := {| 
	ConstraintAutomata.Q := [q2];
	ConstraintAutomata.N := [e;g];
	ConstraintAutomata.T := filter3rel;
	ConstraintAutomata.Q0 := [q2]
|}.
(*Definition sync4rel (s: sync4StatesType) :=
	match s with
		 | q3 => [([f;h], ConstraintAutomata.eqDc nat f h  , q3)] 
	end. *)

Definition merger4rel (s: sync5StatesType) :=
	match s with
		 | q4 => [([f;h], ConstraintAutomata.eqDc nat f h , q4);
              ([g;h], ConstraintAutomata.eqDc nat g h , q4)] 
	end.

Definition merger4Automaton := {| 
	ConstraintAutomata.Q := [q4];
	ConstraintAutomata.N := [f;g;h];
	ConstraintAutomata.T := merger4rel;
	ConstraintAutomata.Q0 := [q4]
|}.

(*Definition sync4Automaton := {| 
	ConstraintAutomata.Q := [q3];
	ConstraintAutomata.N := [f;h];
	ConstraintAutomata.T := sync4rel;
	ConstraintAutomata.Q0 := [q3]
|}.
Definition sync5rel (s: sync5StatesType) :=
	match s with
		 | q4 => [([g;h], ConstraintAutomata.eqDc nat g h  , q4)] 
	end.
Definition sync5Automaton := {| 
	ConstraintAutomata.Q := [q4];
	ConstraintAutomata.N := [g;h];
	ConstraintAutomata.T := sync5rel;
	ConstraintAutomata.Q0 := [q4]
|}. *)
Definition merger6rel (s: merger6StatesType) :=
	match s with
		 | q5 => [([b;x], ConstraintAutomata.eqDc nat b x , q5);
              ([h;x], ConstraintAutomata.eqDc nat h x , q5)] 
	end.
Definition merger6Automaton := {| 
	ConstraintAutomata.Q := [q5];
	ConstraintAutomata.N := [b;x;h];
	ConstraintAutomata.T := merger6rel;
	ConstraintAutomata.Q0 := [q5]
|}.
Definition replicator7rel (s: replicator7StatesType) :=
	match s with
		 | q6 => [([x;i;j], ConstraintAutomata.andDc (ConstraintAutomata.eqDc nat x i) (ConstraintAutomata.eqDc nat x j) , q6)] 
	end.
Definition replicator7Automaton := {| 
	ConstraintAutomata.Q := [q6];
	ConstraintAutomata.N := [x;i;j];
	ConstraintAutomata.T := replicator7rel;
	ConstraintAutomata.Q0 := [q6]
|}.
Definition sync8rel (s: sync8StatesType) :=
	match s with
		 | q7 => [([i;k], ConstraintAutomata.eqDc nat i k  , q7)] 
	end.
Definition sync8Automaton := {| 
	ConstraintAutomata.Q := [q7];
	ConstraintAutomata.N := [i;k];
	ConstraintAutomata.T := sync8rel;
	ConstraintAutomata.Q0 := [q7]
|}.

Definition swap01 (n:nat) :=
  match n with
  | 0 => 1
  | 1 => 0
  | S o => S o
  end.

Definition transformer9rel (s: transformer9StatesType) :=
	match s with
		 | q8 => [([j;l], ConstraintAutomata.trDc swap01 j l , q8)] 
	end.
Definition transformer9Automaton := {| 
	ConstraintAutomata.Q := [q8];
	ConstraintAutomata.N := [j;l];
	ConstraintAutomata.T := transformer9rel;
	ConstraintAutomata.Q0 := [q8]
|}.
Definition sync10rel (s: sync10StatesType) :=
	match s with
		 | q9 => [([l;m], ConstraintAutomata.eqDc nat l m  , q9)] 
	end.
Definition sync10Automaton := {| 
	ConstraintAutomata.Q := [q9];
	ConstraintAutomata.N := [l;m];
	ConstraintAutomata.T := sync10rel;
	ConstraintAutomata.Q0 := [q9]
|}.
Definition fifo11rel (s: fifo11StatesType) :=
	match s with
		 | q10 => [([k], ConstraintAutomata.dc k 0 , p0); ([k], ConstraintAutomata.dc k 1 , p1)]
		 | p0 => [([n], ConstraintAutomata.dc n 0 , q10)] 
		 | p1 => [([n], ConstraintAutomata.dc n 1 , q10)] 
	end.
Definition fifo11Automaton := {| 
	ConstraintAutomata.Q := [q10;p0;p1];
	ConstraintAutomata.N := [k;n];
	ConstraintAutomata.T := fifo11rel;
	ConstraintAutomata.Q0 := [q10]
|}.
Definition merger12rel (s: merger12StatesType) :=
	match s with
		 | q11 => [([m;c], ConstraintAutomata.eqDc nat m c , q11);
               ([n;c], ConstraintAutomata.eqDc nat n c , q11)] 
	end.
Definition merger12Automaton := {| 
	ConstraintAutomata.Q := [q11];
	ConstraintAutomata.N := [m;n;c];
	ConstraintAutomata.T := merger12rel;
	ConstraintAutomata.Q0 := [q11]
|}.
Definition replicator1filter2Product := ProductAutomata.buildPA replicator1Automaton filter2Automaton.
Definition replicator1filter3Product := ProductAutomata.buildPA replicator1filter2Product filter3Automaton.
Definition replicator1sync4Product := ProductAutomata.buildPA replicator1filter3Product merger4Automaton.
(* Definition replicator1sync5Product := ProductAutomata.buildPA replicator1sync4Product sync5Automaton. *)
Definition replicator1merger6Product := ProductAutomata.buildPA replicator1sync4Product merger6Automaton.
Definition replicator1replicator7Product := ProductAutomata.buildPA replicator1merger6Product replicator7Automaton.
Definition replicator1sync8Product := ProductAutomata.buildPA replicator1replicator7Product sync8Automaton.
Definition replicator1transformer9Product := ProductAutomata.buildPA replicator1sync8Product transformer9Automaton.
Definition replicator1sync10Product := ProductAutomata.buildPA replicator1transformer9Product sync10Automaton.
Definition replicator1fifo11Product := ProductAutomata.buildPA replicator1sync10Product fifo11Automaton.
Definition replicator1merger12Product := ProductAutomata.buildPA replicator1fifo11Product merger12Automaton.

(*Eval compute in length(ConstraintAutomata.T replicator1merger12Product (q0,q1,q2,q4,q5,q6,q7,q8,q9,q10,q11)).*)

(*We may state that from a initial state of the automaton (i.e., possible data gateway into *)
(* it is possible that a given traffic light may be open for an amount of time   *)
(* which may disturb pedestrians waiting to cross the road. *)
(* We may split this properties into two lemmas *)

(* The first one states that, from any initial state of te automaton, it is not possible  *)
(* to repeat the same state (i.e., the same signal) if data have left from a (the sensor) *)
(* to c (the receiver)                                                                    *)

Lemma possibleTrafficLightToBeOpenedNotTheSame : forall state,forall transition,
  In (state) (ConstraintAutomata.Q0 replicator1merger12Product) /\ 
  In (transition) (ConstraintAutomata.T replicator1merger12Product state) /\
  In (a) (fst(fst(transition))) /\ In (c) (fst(fst(transition))) -> 
  snd(transition) <> (q0,q1,q2,q4,q5,q6,q7,q8,q9,q10,q11).
Proof.
intros. destruct H.
simpl in H. destruct H. destruct H0.
- rewrite <- H in H0. vm_compute in H0. repeat (destruct H0). 
+ simpl; discriminate.
+ simpl; discriminate.
+ simpl; discriminate.
+ simpl; discriminate.
+ simpl; discriminate.
+ simpl; discriminate.
+ simpl; discriminate.
+ simpl; discriminate.
+ destruct H1. simpl in H1. destruct H1. inversion H1. destruct H1. inversion H1. destruct H1. inversion H1. inversion H1.
- inversion H.
Qed.

(* And now, we may state that, from any state reached from a initial state, they cannot reach a
scenario where one of the traffic light have dhe same data*)
Lemma possibleTrafficLightToBeOpenedNotTheSame2 : forall state,forall transition,
  In (state) (ConstraintAutomata.Q replicator1merger12Product) /\ 
  In (transition) (ConstraintAutomata.T replicator1merger12Product state) /\
  In (a) (fst(fst(transition))) /\ In (c) (fst(fst(transition))) -> 
  snd(transition) <> (state).
Proof.
intros. destruct H.
simpl in H. destruct H. destruct H0.
- rewrite <- H in H0. vm_compute in H0. repeat (destruct H0). 
+ rewrite <- H. simpl; discriminate.
+ rewrite <- H. simpl; discriminate.
+ rewrite <- H. simpl; discriminate.
+ rewrite <- H. simpl; discriminate.
+ rewrite <- H. simpl; discriminate.
+ rewrite <- H. simpl; discriminate.
+ rewrite <- H. simpl; discriminate.
+ rewrite <- H. simpl; discriminate.
+ destruct H1. simpl in H1. destruct H1. inversion H1. destruct H1. inversion H1. destruct H1. inversion H1. inversion H1.
- destruct H. destruct H0.
 rewrite <- H in H0. vm_compute in H0. repeat (destruct H0). 
+ rewrite <- H. simpl; discriminate.
+ rewrite <- H. simpl; discriminate.
+ rewrite <- H. destruct H1. simpl in H1. destruct H1. inversion H1. destruct H1. inversion H1. destruct H1. inversion H1. destruct H1.
+ destruct H. destruct H0 .
  rewrite <- H in H0. vm_compute in H0. repeat (destruct H0). 
  rewrite <- H. simpl; discriminate.
  rewrite <- H. simpl; discriminate.
  rewrite <- H. destruct H1. simpl in H1. destruct H1. inversion H1. destruct H1. inversion H1. destruct H1. inversion H1. destruct H1.
  inversion H.
Qed.




(*data flow*)
Definition dataAssignmentA (n:nat) := 
    match n with
    | 0 =>  1
    | 1 =>  (1)
    | 2 =>  0
    | S p =>  0
    end. 

  Definition dataAssignmentB (n:nat) :=
    match n with
    | 0 =>  1
    | 1 =>  (1)
    | 2 =>  0
    | S p =>  0
    end.

  Definition dataAssignmentC (n:nat) :=
    match n with
    | 0 =>  0
    | 1 =>  (0)
    | 2 =>  0
    | S p =>  0
    end.

  Definition dataAssignmentD (n:nat) :=
    match n with
    | 0 =>  1
    | 1 =>  (1)
    | 2 =>  0
    | S p =>  0
    end.

  Definition dataAssignmentE (n:nat) :=
    match n with
    | 0 =>  1
    | 1 =>  (1)
    | 2 =>  0
    | S p =>  0
    end.

  Definition dataAssignmentF (n:nat) :=
    match n with
    | 0 =>  1
    | 1 =>  (1)
    | 2 =>  0
    | S p =>  0
    end.

  Definition dataAssignmentG (n:nat) :=
    match n with
    | 0 =>  1
    | 1 =>  (1)
    | 2 =>  0
    | S p =>  0
    end.

  Definition dataAssignmentH (n:nat) :=
    match n with
    | 0 =>  1
    | 1 =>  (1)
    | 2 =>  0
    | S p =>  0
    end.

  Definition dataAssignmentI (n:nat) :=
    match n with
    | 0 =>  1
    | 1 =>  (1)
    | 2 =>  0
    | S p =>  0
    end.

  Definition dataAssignmentJ (n:nat) :=
    match n with
    | 0 =>  1
    | 1 =>  (1)
    | 2 =>  0
    | S p =>  0
    end.

  Definition dataAssignmentK (n:nat) :=
    match n with
    | 0 =>  1
    | 1 =>  (1)
    | 2 =>  0
    | S p =>  0
    end.

  Definition dataAssignmentL (n:nat) :=
    match n with
    | 0 =>  0
    | 1 =>  (1)
    | 2 =>  0
    | S p =>  0
    end.

  Definition dataAssignmentM (n:nat) :=
    match n with
    | 0 =>  0
    | 1 =>  (0)
    | 2 =>  0
    | S p =>  0
    end.

  Definition dataAssignmentN (n:nat) :=
    match n with
    | 0 =>  1
    | 1 =>  (1)
    | 2 =>  0
    | S p =>  0
    end.

  Definition dataAssignmentX (n:nat) :=
    match n with
    | 0 =>  1
    | 1 =>  (1)
    | 2 =>  0
    | S p =>  0
    end.

   Definition timeStampSequencerA(n:nat) : QArith_base.Q :=
    match n with
    | 0 => 2#1
    | 1 => 6#1
    | 2 => 8#1
    | 3 => 11#1
    | 4 => 14#1
    | 5 => 17#1
    | S p =>  Z.of_nat(S p) + 17#1
    end.

  Definition timeStampSequencerB (n:nat) : QArith_base.Q :=
    match n with
    | 0 => 30#1
    | 1 => 70#1
    | 2 => 90#1
    | 3 => 120#1
    | 4 => 150#1
    | 5 => 180#1
    | S p =>  Z.of_nat(S p) + 190#1
    end.


  Definition timeStampSequencerC (n:nat) : QArith_base.Q :=
    match n with
    | 0 => 2#1
    | 1 => 6#1
    | 2 => 8#1
    | 3 => 11#1
    | 4 => 14#1
    | 5 => 17#1
    | S p =>  Z.of_nat(S p) + 19#1
    end.

  Definition timeStampSequencerD (n:nat) : QArith_base.Q :=
    match n with
    | 0 => 2#1
    | 1 => 6#1
    | 2 => 8#1
    | 3 => 11#1
    | 4 => 14#1
    | 5 => 17#1
    | S p =>  Z.of_nat(S p) + 17#1
    end.

  Definition timeStampSequencerE (n:nat) : QArith_base.Q :=
    match n with
    | 0 => 2#1
    | 1 => 6#1
    | 2 => 8#1
    | 3 => 11#1
    | 4 => 14#1
    | 5 => 17#1
    | S p =>  Z.of_nat(S p) + 17#1
    end.

  Definition timeStampSequencerF (n:nat) : QArith_base.Q :=
    match n with (*filtro de cima*)
    | 0 => 2#1
    | 1 => 6#1
    | 2 => 8#1
    | 3 => 11#1
    | 4 => 14#1
    | 5 => 17#1
    | S p =>  Z.of_nat(S p) + 17#1
    end.


  Definition timeStampSequencerG (n:nat) : QArith_base.Q :=
    match n with
    | 0 => 30#1
    | 1 => 60#1
    | 2 => 80#1
    | 3 => 110#1
    | 4 => 140#1
    | 5 => 170#1
    | S p =>  Z.of_nat(S p) + 170#1
    end.

  Definition timeStampSequencerH (n:nat) : QArith_base.Q :=
    match n with
    | 0 => 2#1
    | 1 => 6#1
    | 2 => 8#1
    | 3 => 11#1
    | 4 => 14#1
    | 5 => 17#1
    | S p =>  Z.of_nat(S p) + 17#1
    end.

   Definition timeStampSequencerI(n:nat) : QArith_base.Q :=
    match n with
    | 0 => 2#1
    | 1 => 6#1
    | 2 => 8#1
    | 3 => 11#1
    | 4 => 14#1
    | 5 => 17#1
    | S p =>  Z.of_nat(S p) + 17#1
    end.


   Definition timeStampSequencerJ(n:nat) : QArith_base.Q :=
    match n with
    | 0 => 2#1
    | 1 => 6#1
    | 2 => 8#1
    | 3 => 11#1
    | 4 => 14#1
    | 5 => 17#1
    | S p =>  Z.of_nat(S p) + 17#1
    end.

   Definition timeStampSequencerK(n:nat) : QArith_base.Q :=
    match n with
    | 0 => 2#1
    | 1 => 6#1
    | 2 => 8#1
    | 3 => 11#1
    | 4 => 14#1
    | 5 => 17#1
    | S p =>  Z.of_nat(S p) + 17#1
    end.

   Definition timeStampSequencerL(n:nat) : QArith_base.Q :=
    match n with
    | 0 => 2#1
    | 1 => 6#1
    | 2 => 8#1
    | 3 => 11#1
    | 4 => 14#1
    | 5 => 17#1
    | S p =>  Z.of_nat(S p) + 17#1
    end.

   Definition timeStampSequencerM(n:nat) : QArith_base.Q :=
    match n with
    | 0 => 2#1
    | 1 => 6#1
    | 2 => 8#1
    | 3 => 11#1
    | 4 => 14#1
    | 5 => 17#1
    | S p =>  Z.of_nat(S p) + 17#1
    end.

   Definition timeStampSequencerN (n:nat) : QArith_base.Q :=
    match n with
    | 0 => 30#1 
    | 1 => 50#1
    | 2 => 80#1
    | 3 => 110#1
    | 4 => 140#1
    | 5 => 170#1
    | S p =>  Z.of_nat (S p) + 170#1 
    end.

   Definition timeStampSequencerX(n:nat) : QArith_base.Q :=
    match n with
    | 0 => 2#1
    | 1 => 6#1
    | 2 => 8#1
    | 3 => 11#1
    | 4 => 14#1
    | 5 => 17#1
    | S p =>  Z.of_nat(S p) + 17#1
    end.

  Lemma timeStampSequencerAHolds : forall p, 
    Qlt (timeStampSequencerA p) (timeStampSequencerA (S p)).
  Proof.
  intros. destruct p. unfold timeStampSequencerA. reflexivity.
  unfold timeStampSequencerA. case (p). reflexivity.
  intros n0. case (n0). reflexivity.
  intros n1. case (n1). reflexivity.
  intros n2. case (n2). reflexivity.
  intros n3. case (n3). reflexivity.
  intros n4. unfold Qlt. apply orderZofNat.  Defined.
  
  Lemma timeStampSequencerBHolds : forall p, 
    Qlt (timeStampSequencerB p) (timeStampSequencerB (S p)). 
  Proof.
  intros. destruct p. unfold timeStampSequencerB. reflexivity.
  unfold timeStampSequencerB. case (p). reflexivity.
  intros n0. case (n0). reflexivity.
  intros n1. case (n1). reflexivity.
  intros n2. case (n2). reflexivity.
  intros n3. case (n3). reflexivity.
  intros n4. apply orderZofNat. Defined.

  Lemma timeStampSequencerCHolds : forall p, 
    Qlt (timeStampSequencerC p) (timeStampSequencerC (S p)). 
  Proof.
  intros. destruct p. unfold timeStampSequencerC. reflexivity.
  unfold timeStampSequencerC. case (p). reflexivity.
  intros n0. case (n0). reflexivity.
  intros n1. case (n1). reflexivity.
  intros n2. case (n2). reflexivity.
  intros n3. case (n3). reflexivity.
  intros n4. apply orderZofNat. Defined.

  Lemma timeStampSequencerDHolds : forall p, 
    Qlt (timeStampSequencerD p) (timeStampSequencerD (S p)). 
  Proof.
  intros. destruct p. unfold timeStampSequencerD. reflexivity.
  unfold timeStampSequencerD. case (p). reflexivity.
  intros n0. case (n0). reflexivity.
  intros n1. case (n1). reflexivity.
  intros n2. case (n2). reflexivity.
  intros n3. case (n3). reflexivity.
  intros n4. apply orderZofNat. Defined.

  Lemma timeStampSequencerEHolds : forall p, 
    Qlt (timeStampSequencerE p) (timeStampSequencerE (S p)). 
  Proof.
  intros. destruct p. unfold timeStampSequencerE. reflexivity.
  unfold timeStampSequencerE. case (p). reflexivity.
  intros n0. case (n0). reflexivity.
  intros n1. case (n1). reflexivity.
  intros n2. case (n2). reflexivity.
  intros n3. case (n3). reflexivity.
  intros n4. apply orderZofNat. Defined.

  Lemma timeStampSequencerFHolds : forall p, 
    Qlt (timeStampSequencerF p) (timeStampSequencerF (S p)). 
  Proof.
  intros. destruct p. unfold timeStampSequencerF. reflexivity.
  unfold timeStampSequencerF. case (p). reflexivity.
  intros n0. case (n0). reflexivity.
  intros n1. case (n1). reflexivity.
  intros n2. case (n2). reflexivity.
  intros n3. case (n3). reflexivity.
  intros n4. apply orderZofNat. Defined.


  Lemma timeStampSequencerGHolds : forall p, 
    Qlt (timeStampSequencerG p) (timeStampSequencerG (S p)). 
  Proof.
  intros. destruct p. unfold timeStampSequencerG. reflexivity.
  unfold timeStampSequencerG. case (p). reflexivity.
  intros n0. case (n0). reflexivity.
  intros n1. case (n1). reflexivity.
  intros n2. case (n2). reflexivity.
  intros n3. case (n3). reflexivity.
  intros n4. apply orderZofNat. Defined.

  Lemma timeStampSequencerHHolds : forall p, 
    Qlt (timeStampSequencerH p) (timeStampSequencerH (S p)). 
  Proof.
  intros. destruct p. unfold timeStampSequencerH. reflexivity.
  unfold timeStampSequencerH. case (p). reflexivity.
  intros n0. case (n0). reflexivity.
  intros n1. case (n1). reflexivity.
  intros n2. case (n2). reflexivity.
  intros n3. case (n3). reflexivity.
  intros n4. apply orderZofNat. Defined.

  Lemma timeStampSequencerIHolds : forall p, 
    Qlt (timeStampSequencerI p) (timeStampSequencerI (S p)).
  Proof.
  intros. destruct p. unfold timeStampSequencerI. reflexivity.
  unfold timeStampSequencerI. case (p). reflexivity.
  intros n0. case (n0). reflexivity.
  intros n1. case (n1). reflexivity.
  intros n2. case (n2). reflexivity.
  intros n3. case (n3). reflexivity.
  intros n4. unfold Qlt. apply orderZofNat.  Defined.

  Lemma timeStampSequencerJHolds : forall p, 
    Qlt (timeStampSequencerJ p) (timeStampSequencerJ (S p)).
  Proof.
  intros. destruct p. unfold timeStampSequencerJ. reflexivity.
  unfold timeStampSequencerJ. case (p). reflexivity.
  intros n0. case (n0). reflexivity.
  intros n1. case (n1). reflexivity.
  intros n2. case (n2). reflexivity.
  intros n3. case (n3). reflexivity.
  intros n4. unfold Qlt. apply orderZofNat.  Defined.

  Lemma timeStampSequencerKHolds : forall p, 
    Qlt (timeStampSequencerK p) (timeStampSequencerK (S p)).
  Proof.
  intros. destruct p. unfold timeStampSequencerK. reflexivity.
  unfold timeStampSequencerK. case (p). reflexivity.
  intros n0. case (n0). reflexivity.
  intros n1. case (n1). reflexivity.
  intros n2. case (n2). reflexivity.
  intros n3. case (n3). reflexivity.
  intros n4. unfold Qlt. apply orderZofNat.  Defined.

  Lemma timeStampSequencerLHolds : forall p, 
    Qlt (timeStampSequencerL p) (timeStampSequencerL (S p)).
  Proof.
  intros. destruct p. unfold timeStampSequencerL. reflexivity.
  unfold timeStampSequencerL. case (p). reflexivity.
  intros n0. case (n0). reflexivity.
  intros n1. case (n1). reflexivity.
  intros n2. case (n2). reflexivity.
  intros n3. case (n3). reflexivity.
  intros n4. unfold Qlt. apply orderZofNat.  Defined.

  Lemma timeStampSequencerMHolds : forall p, 
    Qlt (timeStampSequencerM p) (timeStampSequencerM (S p)).
  Proof.
  intros. destruct p. unfold timeStampSequencerM. reflexivity.
  unfold timeStampSequencerM. case (p). reflexivity.
  intros n0. case (n0). reflexivity.
  intros n1. case (n1). reflexivity.
  intros n2. case (n2). reflexivity.
  intros n3. case (n3). reflexivity.
  intros n4. unfold Qlt. apply orderZofNat.  Defined.

  Lemma timeStampSequencerNHolds : forall p, 
    Qlt (timeStampSequencerN p) (timeStampSequencerN (S p)).
  Proof.
  intros. destruct p. unfold timeStampSequencerN. reflexivity.
  unfold timeStampSequencerN. case (p). reflexivity.
  intros n0. case (n0). reflexivity.
  intros n1. case (n1). reflexivity.
  intros n2. case (n2). reflexivity.
  intros n3. case (n3). reflexivity.
  intros n4. unfold Qlt. apply orderZofNat.  Defined.

  Lemma timeStampSequencerXHolds : forall p, 
    Qlt (timeStampSequencerX p) (timeStampSequencerX (S p)).
  Proof.
  intros. destruct p. unfold timeStampSequencerX. reflexivity.
  unfold timeStampSequencerX. case (p). reflexivity.
  intros n0. case (n0). reflexivity.
  intros n1. case (n1). reflexivity.
  intros n2. case (n2). reflexivity.
  intros n3. case (n3). reflexivity.
  intros n4. unfold Qlt. apply orderZofNat.  Defined.


  Definition portA := {|
        ConstraintAutomata.id := a;
        ConstraintAutomata.dataAssignment := dataAssignmentA;
        ConstraintAutomata.timeStamp := timeStampSequencerA;
        ConstraintAutomata.tdsCond := timeStampSequencerAHolds;
        ConstraintAutomata.index := 0 |}.

  Definition portB := {|
        ConstraintAutomata.id := b;
        ConstraintAutomata.dataAssignment := dataAssignmentB;
        ConstraintAutomata.timeStamp := timeStampSequencerB;
        ConstraintAutomata.tdsCond := timeStampSequencerBHolds;
        ConstraintAutomata.index := 0 |}.

  Definition portC := {|
        ConstraintAutomata.id := c;
        ConstraintAutomata.dataAssignment := dataAssignmentC;
        ConstraintAutomata.timeStamp := timeStampSequencerC;
        ConstraintAutomata.tdsCond := timeStampSequencerCHolds;
        ConstraintAutomata.index := 0 |}.

  Definition portD := {|
        ConstraintAutomata.id := d;
        ConstraintAutomata.dataAssignment := dataAssignmentD;
        ConstraintAutomata.timeStamp := timeStampSequencerD;
        ConstraintAutomata.tdsCond := timeStampSequencerDHolds;
        ConstraintAutomata.index := 0 |}.

  Definition portE := {|
        ConstraintAutomata.id := e;
        ConstraintAutomata.dataAssignment := dataAssignmentE;
        ConstraintAutomata.timeStamp := timeStampSequencerE;
        ConstraintAutomata.tdsCond := timeStampSequencerEHolds;
        ConstraintAutomata.index := 0 |}.

  Definition portF := {|
        ConstraintAutomata.id := f;
        ConstraintAutomata.dataAssignment := dataAssignmentF;
        ConstraintAutomata.timeStamp := timeStampSequencerF;
        ConstraintAutomata.tdsCond := timeStampSequencerFHolds;
        ConstraintAutomata.index := 0 |}.

  Definition portG := {|
        ConstraintAutomata.id := g;
        ConstraintAutomata.dataAssignment := dataAssignmentG;
        ConstraintAutomata.timeStamp := timeStampSequencerG;
        ConstraintAutomata.tdsCond := timeStampSequencerGHolds;
        ConstraintAutomata.index := 0 |}.

  Definition portH := {|
        ConstraintAutomata.id := h;
        ConstraintAutomata.dataAssignment := dataAssignmentH;
        ConstraintAutomata.timeStamp := timeStampSequencerH;
        ConstraintAutomata.tdsCond := timeStampSequencerHHolds;
        ConstraintAutomata.index := 0 |}.

  Definition portI := {|
        ConstraintAutomata.id := i;
        ConstraintAutomata.dataAssignment := dataAssignmentI;
        ConstraintAutomata.timeStamp := timeStampSequencerI;
        ConstraintAutomata.tdsCond := timeStampSequencerIHolds;
        ConstraintAutomata.index := 0 |}.

  Definition portJ := {|
        ConstraintAutomata.id := j;
        ConstraintAutomata.dataAssignment := dataAssignmentJ;
        ConstraintAutomata.timeStamp := timeStampSequencerJ;
        ConstraintAutomata.tdsCond := timeStampSequencerJHolds;
        ConstraintAutomata.index := 0 |}.

  Definition portK := {|
        ConstraintAutomata.id := k;
        ConstraintAutomata.dataAssignment := dataAssignmentK;
        ConstraintAutomata.timeStamp := timeStampSequencerK;
        ConstraintAutomata.tdsCond := timeStampSequencerKHolds;
        ConstraintAutomata.index := 0 |}.

  Definition portL := {|
        ConstraintAutomata.id := l;
        ConstraintAutomata.dataAssignment := dataAssignmentL;
        ConstraintAutomata.timeStamp := timeStampSequencerL;
        ConstraintAutomata.tdsCond := timeStampSequencerLHolds;
        ConstraintAutomata.index := 0 |}.

  Definition portM := {|
        ConstraintAutomata.id := m;
        ConstraintAutomata.dataAssignment := dataAssignmentM;
        ConstraintAutomata.timeStamp := timeStampSequencerM;
        ConstraintAutomata.tdsCond := timeStampSequencerMHolds;
        ConstraintAutomata.index := 0 |}.

  Definition portN := {|
        ConstraintAutomata.id := n;
        ConstraintAutomata.dataAssignment := dataAssignmentN;
        ConstraintAutomata.timeStamp := timeStampSequencerN;
        ConstraintAutomata.tdsCond := timeStampSequencerNHolds;
        ConstraintAutomata.index := 0 |}.

  Definition portX := {|
        ConstraintAutomata.id := x;
        ConstraintAutomata.dataAssignment := dataAssignmentX;
        ConstraintAutomata.timeStamp := timeStampSequencerX;
        ConstraintAutomata.tdsCond := timeStampSequencerXHolds;
        ConstraintAutomata.index := 0 |}.

  Definition dataFlow := [portA;portB;portC;portD;portE;portF;portG;portH;portI;
                        portJ;portK;portL;portM;portN;portX].

(*Time Eval vm_compute in ConstraintAutomata.run replicator1merger12Product dataFlow 5.
*)
  Require Extraction.
  Extraction Language Haskell.
  Extraction "trafficLightsCertified" replicator1merger12Product.